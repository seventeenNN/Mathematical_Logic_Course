""" CSeq C Sequentialization Framework
	module stubs

Credits:
    CSeq Translator modules are built on top of
    pycparserext by Andreas Klockner, which extends
    pycparser by Eli Bendersky (BSD license), which in turn embeds
    PLY, by David M. Beazley.

Author:
    Omar Inverso

Changes:
    2020.03.25 (CSeq 2.0)
    2019.11.27 [SV-COMP 2020]    
    2019.11.26  identification of blocks (for the new symbol table)
    2019.11.21  workaround to pycparserext/pycparser removing the encloding round brackets in expression statements
    2019.11.19  fixed linemapping (removing empty lines breaks the map!)
    2019.11.13  fixed coords  
    2019.10.04 [SV-COMP 2020]
    2019.10.04  added info() to print informative messages (verbosity level 2)
    2019.03.24  more precise linemarking (row,col thanks to pycparser >=2.18)
    2018.11.23 [SV-COMP 2019]
    2018.11.23  linemarking can be disabled in translation modules via visit(nolinemarking=False), so that
                one can visit any part of the AST without worrying about breaking linemarking
    2018.11.20  fixed self.log()
    2018.10.29  error message formatting
    2018.10.28  fixed broken indentation when linemarking, at last
    2018.10.28  rolled back linemarking from cseq-1.5-parallel to svcomp2016 (see DISABLED in visit())
    2018.10.20  just added a comment about linemapping in visit()
    2018.07.19  warning messages may now display the input coords
    2018.07.19  other slight changes to exception handling
    2017.12.09  added newlines before and after linecoord markers (see visit())
    2016.09.24  added errors with code snippets
    2016.09.22  added self.scope (for now the same as self.currentFunct)
    2016.09.06  bugfix (insertheader(): top headers may be empty, or None)
    2015.07.16  add removelinenumbers to strip off fake include (SV-COMP workaround)
    2015.06.29  fixed coords calculation for parsing errors
    2015.01.07  added self.stacknodes as the stack of nodes in the AST currently being visited
    2014.12.09  major reorganisation to accomodate new CSeq framework
    2014.10.22  implemented linemapping (now disabled to improve performance and stability - it needs proper testing before releasing)
    2014.10.15  implemented self.stack to examine the stack of calls to visit() (modules may use this)
    2014.06.02  introduced specific module.ModuleError exception for detailed error handling
    2014.12.24 (CSeq 1.0beta)

To do:
  - get rid of workaround in Translator class
  - review and possibly document module param usage
  - add optional code snippets to warning messages
  - rename basic modules to Wrappers? (to match other documentation)
  - new module class that takes C and returns a generic string,
    not a translator, not a wrapper, but something to extract information on the files,
    for example to list the names of functions, or to calculate source code complexity
    according to some metric
  - new module class for term-rewriting (until fixpoint)

Notes:
  - in order for linemapping to work,
    newlines should never be explicitly added to the code snippets generated by __visit_XYZ()

Notes on line-mapping.

In general, using linemarkers from the beginning and
propagating them across modules,
so that each module would have references to the original input,
can work well.

However since pycparser does not handle line control directives,
we need some workaround to implement this mechanism.

This is a two-step process:

- step 1: while generating the output,
		  coord markers (see cpp line control)
		  are inserted whenever coord information is present.
		  So at a certain line in the output the code will look like:

			  # X             // <-- marker
			  int k = 1239;   // <-- line Y in the output

		  This step is performed in visit().

- step 2: once all the (marked) output is generated,
		  the module does not return its output yet, as
		  pycparser does not support line control.

		  The markers need to be removed from the output,
		  but before that, the information stored in them is used
		  to map input lines to output lines according
		  to the following mechanism.

		  The line number from the marker corresponds to the input line number.
		  The line below the marker is che corresponding line of the output =

			(actual output line including markers) - (number of markers so far).

		  In the example,
		  statement (int k = 1239) from the output file
		  comes from line X of the input file.

		  This is done in generatelinenumbers() at the end of the visit of the AST.

"""

import os, re, sys, time
import pycparserext.ext_c_parser, pycparserext.ext_c_generator, pycparser
import parser, utils


''' Generic module error '''	
class ModuleError(Exception):
	def __init__(self, value): self.value = value
	def __str__(self): return self.value #return repr(self.value)

''' Input syntax clashes with module restrictions '''
class ModuleSyntaxError(Exception): pass

''' Module requests stopping the translation '''
class ModuleChainBreak(ModuleError): pass

''' Error in module parameters '''
class ModuleParamError(ModuleError): pass




class ModuleParam():
	def __init__(self,id,description='',datatype='',default='',optional=''):
		self.id = id
		self.description = description  # description displayed in the help screen by the front-end
		self.datatype = datatype        # type ('int', 'string') checked by the front-end
		self.default = default          # default value
		self.optional = optional        # optional (=True) or mandatory (=False)?

	def isflag(self):
		return (self.datatype == None or self.datatype == '')

	def tostring(self):
		return '%s, \'%s\', %s, %s, %s' % (self.id, self.description, self.default, self.datatype, 'optional' if self.optional else 'mandatory')



class BasicModule():
	def __init__(self):
		# the CSeq environment
		self.cseqenv = None

		# Input and output of the module
		self.input = ''
		self.output = ''

		# Module parameters
		self.inputparamdefs = []
		self.outputparamdefs = []

	def name(self): return self.__class__.__name__

	def loadfromstring(self,string,env):
		# At this point the module expects
		# all the input parameters previously set with inputparam()
		# to have a corresponding entry in the cseq environment.
		for p in self.inputparamdefs:
			if not p.optional and p.id not in env.paramvalues:
				raise ModuleParamError('module \'%s\' requires parameter --%s.' % (self.name(), p.id))

	def getLastCoords(self):
		coords = ''

		try:
			#coords = str(self._mapbacklineno(self.currentinputlineno)[1])+':'
			#coords += str(self._mapbacklineno(self.currentinputlineno)[0])
			(lineno,file) = self._mapbacklineno(self.currentinputlineno)
			coords = "%s:%s" % (file,lineno)
		except:
			coords = ''

		return coords

	#def log(self,string,lineno=False):
	def log(self,string):
		if self.cseqenv.verbosity > 0:
			tag = 'module %s:' % self.name()
			taglen = len(tag)
			tag = utils.colors.FAINT+tag+utils.colors.NO
			coords = self.getLastCoords()
			print tag, #print(tag, end=" ")
			print ('\n'+' '*taglen).join([l for l in string.split('\n')])

	#def debug(self,string,snippet=False,lineno=False):
	def debug(self,string):
		if self.cseqenv.verbosity > 1:
			tag = 'module %s:' % self.name()
			taglen = len(tag)
			tag = utils.colors.FAINT+tag+utils.colors.NO
			coords = self.getLastCoords()
			print tag, #print(tag, end=" ")
			print ('\n'+' '*taglen).join([l for l in string.split('\n')])

	#def warn(self,string,snippet=False,lineno=False):
	def warn(self,string):
		#if self.cseqenv.verbosity > 0:
		#	tag = 'module %s: warning:' % self.name()
		#	taglen = len(tag)
		#	tag = utils.colors.FAINT+tag+utils.colors.NO
		#	coords = self.getLastCoords()
		#
		#	if lineno: tag += ' '+coords+':'
		#
		#	print tag, #print(tag, end=" ")
		#	print ('\n'+' '*taglen).join([l for l in string.split('\n')])
		if self.cseqenv.verbosity > 0:
			tag = 'module %s: warning:' % self.name()
			taglen = len(tag)
			tag = utils.colors.FAINT+tag+utils.colors.NO
			print tag, #print(tag, end=" ")
			print ('\n'+' '*taglen).join([l for l in string.split('\n')])

	#def error(self,string,snippet=False,lineno=False):
	def error(self,string):
		#coords = self.getLastCoords() if lineno else ''
		#string = coords+': '+string if coords != '' else ' '+string
		#
		#if not snippet: raise ModuleError(string)
		#else: raise ModuleSyntaxError(string)
		raise ModuleError(string)

	def save(self,filename):
		outfile = open(filename,"w")
		outfile.write(self.output)
		outfile.close()

	''' parameter handling '''
	def initparams(self,env):
		self.cseqenv = env

		# Initialise input parameters when needed
		for p in self.inputparamdefs:
			if not p.optional and p.default and p.id not in env.paramvalues:
				env.paramvalues[p.id] = p.default

	def inputparam(self,id,description,datatype,default,optional):
		# TODO when adding duplicated input parameters,
		# field 'datatype' should be consistent;
		# all other attributes are left like on the 1st time.
		self.inputparamdefs.append(ModuleParam(id,description,datatype,default,optional))

	def outputparam(self,id,description='',datatype=''):
		self.outputparamdefs.append(ModuleParam(id,description,datatype))

	def getinputparam(self,id):
		return self.cseqenv.paramvalues[id] if id in self.cseqenv.paramvalues else None

	def setoutputparam(self,id,value):
		self.cseqenv.paramvalues[id] = value



class Translator(BasicModule,pycparserext.ext_c_generator.GnuCGenerator):
	indent_level = 0
	INDENT_SPACING = '     '

	def __init__(self):
		super(Translator,self).__init__()

		# Parser module to generate the AST, the symbol table and other data structs.
		self.Parser = parser.Parser()

		# Coords of the last AST node visited
		self.currentinputlineno = 0   # line numbers extracted from coords

		# Coords last extracted from a linemarker
		self.lastinputfile = ''       # input file in the last linemarker
		self.lastinputlineno = 0      # line number since last linemarker
		self.lastoutputlineno = 0     # line number in output

		# Stacks of ongoing recursive visits
		self.stack = []       # class names, example: ['FileAST', 'FuncDef', 'Compound', 'Compound', 'If', 'BinaryOp', 'ArrayRef', 'ID']
		self.stacknodes = []  # AST nodes

		self.scope = ''         # current scope being parsed (for now function names are used, or '' for global scope)
		self.currentFunct = ''  # name of the function being parsed ('' = none) exactly as scope, kept for backwards compatibility

		self.lines = []

		# Input<->Output linemaps
		self.inputtooutput = {}
		self.outputtoinput = {}

		self.linemarking = True

		###### NEW PARSING TABLE START #####
		self.blockid = '0'   # current blockid, as a string '0.y.z'
		self.block = [0]      # current blockid, list of integers
		self.blockd = 0       # current block depth
		self.blockcount = 0   # block no. at the current depth


	# Necessary workarounds for GNU statement expressions
	# (https://gcc.gnu.org/onlinedocs/gcc/Statement-Exprs.html).
	#
	# With pycparserext/pycparser,
	# pretty-printing removes the external round brackets, so 
	# in doubt we put them back.
	#
	# TODO ideally should amend the parser instead.
	#
	def visit_Return(self, n):
		#print ("STACK: %s" %self.stack)
		s = 'return'
		if n.expr: s += ' (' + self.visit(n.expr) +')'
		return s + ';'

	def visit_Assignment(self, n):
		#print ("ASS STACK: >%s<" %self.stack)
		rval_str = self._parenthesize_if(n.rvalue, lambda n: isinstance(n, pycparser.c_ast.Assignment))
		x = '%s %s (%s)' % (self.visit(n.lvalue), n.op, rval_str)
		#print ("code:    >%s<" %x)
		return x


	def visit_Compound(self, n):
		# block-based parsing start
		oldblockcount = None
		
		self.blockd += 1
		
		# Visiting a nested block, or
		# a block at the same depth.
		if self.blockd >= len(self.block):
			oldblockcount = self.blockcount
			self.block.append(self.blockcount)
			self.blockid = '.'.join(str(self.block[i]) for i in range(0,len(self.block)))
			self.blockcount = 0
			#print ("A block[%s] blockd[%s] blockcount[%s] " % (self.block,self.blockd,self.blockcount))
		else:
			self.block.pop()
			self.block.append(self.blockcount+1)
			self.blockid = '.'.join(str(self.block[i]) for i in range(0,len(self.block)))
			self.blockcount +=1
			#print ("B block[%s] blockd[%s] blockcount[%s] " % (self.block,self.blockd,self.blockcount))
		# block-based parsing stop

		# Actual visit.
		#print ("VISITING BLOCK: -%s-" % self.blockid)
		s = super(Translator, self).visit_Compound(n)

		# block-based parsing start
		# Visiting a nested block, or
		# a block at the same depth.
		if oldblockcount is not None:
			self.blockcount = oldblockcount+1
			self.block.pop()
			self.blockid = '.'.join(str(self.block[i]) for i in range(0,len(self.block)))
			#print ("C block[%s] blockd[%s] blockcount[%s] " % (self.block,self.blockd,self.blockcount))
		else:
			#print ("D block[%s] blockd[%s] blockcount[%s] " % (self.block,self.blockd,self.blockcount))
			pass
		#
		self.blockd -= 1
		# block-based parsing stop

		return s
	# workaround END.


	def warn(self,string,snippet=False,lineno=False):
		#if snippet:
		#	print("%s%s%s" % (core.utils.colors.HIGHLIGHT, core.utils.snippet(output,Merger.getLineNo(e),Merger.getColumnNo(e),5,True), core.utils.colors.NO))
		if lineno: string += ' '+self.getLastCoords()+':'
		super(Translator,self).warn(string)


	def error(self,string,snippet=False,lineno=False):
		coords = self.getLastCoords() if lineno else ''
		string = coords+': '+string if coords != '' else ' '+string

		if not snippet: raise ModuleError(string)
		else: raise ModuleSyntaxError(string)


	''' Returns the input line number
		mapping it back from the output of last module to the input of 1st module.

		Returns 0 if unable to map back the line number.
	'''
	def _mapbacklineno(self,lineno):
		# Note: since the same input line may correspond to
		#       multiple lines in the final output,
		#       the tracing has to be done backwards.
		#
		lastmodule = len(self.cseqenv.maps)
		nextkey = 0
		inputfile = ''

		if lineno in self.cseqenv.maps[len(self.cseqenv.maps)-1]:
			firstkey = nextkey = lastkey = lineno

			for modno in reversed(range(0,lastmodule)):
				if nextkey in self.cseqenv.maps[modno] and nextkey != 0:
					lastkey = nextkey
					nextkey = self.cseqenv.maps[modno][nextkey]
				else:
					nextkey = 0

				if modno == 0:
					inputfile = self.cseqenv.outputtofiles[lastkey]

		return (nextkey,inputfile)


	def _make_indent(self,delta=0):
		return (self.indent_level+delta) * self.INDENT_SPACING


	def _getmarker(self,item):   # was: _getCurrentCoords()
		''' NOTE: uncomment instructions below to disable linemapping '''
		#return ''

		''' NOTE: uncomment instructions below to enable linemapping '''
		lineno = str(item.coord.line) if item.coord.line else str(-1)
		return '# %s "<previous_module>"' % (lineno)


	def insertheader(self,h):
		if h is None: return  # nothing to do
		offset = h.count('\n')
		if offset == 0: return  # nothing to do either
		self.output = h + self.output

		# Shift linemapping accordingly.
		for i in range(1,max(self.inputtooutput)):
			if i in self.inputtooutput:
				self.inputtooutput[i] += offset

		#for i in range(max(self.outputtoinput),1):
		for i in reversed(range(1,max(self.outputtoinput))):
			if i in self.outputtoinput:
				self.outputtoinput[i+offset] = self.outputtoinput[i]
				self.outputtoinput[i] = -1


	''' Strip off fake define include and recalculate line numbers
	'''
	def removelinenumbers(self):
		s2 = ''
		status = 0
		top = bottom = 0

		# print "Input to output"
		# for i in self.inputtooutput:
		#     print "%s -> %s" % (i, self.inputtooutput[i])
		# print "Output to input"
		# for i in self.outputtoinput:
		#     print "%s -> %s" % (i, self.outputtoinput[i])
		# utils.saveFile("beforestrip.c", self.output)

		for i, line in enumerate(self.output.split('\n')):
			if '_____STARTSTRIPPINGFROMHERE_____' in line:
				status = 1
				# print '-----> top line: %s' % (i + 1)
				top = i + 1
				continue

			if '_____STOPSTRIPPINGFROMHERE_____' in line:
				status = 2
				# print '-----> bottom line: %s' % (i + 1)
				bottom = i + 1
				continue

			if status == 0 or status == 2:
				s2 += line + '\n'

		offset = bottom - top + 1

		# input file
		#  |     region 1    |     removed region    |  region 2
		#                    ^        offset         ^
		#                   top                   bottom

		# Shift linemapping accordingly.
		for i in reversed(range(1, max(self.inputtooutput))):
			if i in self.inputtooutput:
				if self.inputtooutput[i] > bottom:
					# Shift back if output line in region 2
					self.inputtooutput[i] -= offset
				elif self.inputtooutput[i] >= top:
					# Map to -1 if output line in removed region
					self.inputtooutput[i] = -1

		# #for i in range(max(self.outputtoinput),1):
		m = max(self.outputtoinput)
		for i in range(top, m):
			if (i + offset) in self.outputtoinput:
				self.outputtoinput[i] = self.outputtoinput[i + offset]
			elif i + offset > m:
				self.outputtoinput[i] = -1

		# print "Input to output"
		# for i in self.inputtooutput:
		#     print "%s -> %s" % (i, self.inputtooutput[i])
		# print "Output to input"
		# for i in self.outputtoinput:
		#     print "%s -> %s" % (i, self.outputtoinput[i])
		# utils.saveFile("afterstrip.c", s2)

		self.output = s2


	def loadfromstring(self,string,env):
		# Just for parameter checking
		super(Translator,self).loadfromstring(string,env)

		self.Parser.reset()  # resets all the parser datastructs
		self.Parser.loadfromstring(string)

		self.input = string
		self.ast = self.Parser.ast
		self.output = self.visit(self.ast)

		fileno = str(self.cseqenv.transforms+1).zfill(2)

		# Remove any leading indentation for linemarkers,
		# in case some module breaks the linemarking.
		#
		# For example:
	    #       # 174 "<previous_module>"
	    # is changed to:
	    # # 174 "<previous_module>"
	    #
		# Note: 
		# looks like the only module that needs this fix is the inliner from SVCOMP17-18-19).
		#
		newoutput = ''

		for line in self.output.splitlines():
			newoutput += re.sub(r'(%s)*#'%self.INDENT_SPACING, r'#', line) + '\n'

			#print "0 ---------> %s %s" % (self.name(),    env.inputfile )
			#print "1 ---------> %s" % line
			#print "2 ---------> %s" % re.sub(r'(%s)*#'%self.INDENT_SPACING, r'#', line)
			#if line != re.sub(r'(%s)*#'%self.INDENT_SPACING, r'#', line):
			#	print "3 ---------> actually different!\n"
			#else: print "3 ---------> \n",

			##newoutput += line + '\n\n'

		self.markedoutput = newoutput
		self.output = newoutput

		# Generate the linemap and remove linemarkers from self.output
		self.generatelinenumbers(env.transforms)


	def getlinenumbertable(self):
		linenumbers = ''

		for i in range(1,self.lastoutputlineno+1):
			#if self.outputtoinput.has_key(i):
			if i in self.outputtoinput:
				a = int(self.outputtoinput[i])
				b = int(i)
				linenumbers += "%d <- %d\n" % (self.outputtoinput[i],i)

		return linenumbers


	def generatelinenumbers(self,num):
		''' the difference with the std preprocessor linemapping (see merger.py) is that
			here we assume that when there are no linemarkers the output line
			always generates from the input coordinate fetched from the last linemarker found.
		'''
		inputlineno = 0      # actual input line number including line with markers
		inputmarkercnt = 0   # count the linemarkers in the input (each linemarker takes one line)
		cleanoutput = ''   # output without linemarkers

		for line in self.output.splitlines():
			inputlineno +=1

			if line.startswith('# '):
				inputmarkercnt += 1
				(self.lastinputlineno,self.lastinputfile,self.lastflag) = utils.linemarkerinfo(line)
			else:
				if line == '':   # avoid mapping empty lines
					#print "EMPTY LINE"
					pass
				else:
					#  > > >   Our line map   < < <
					self.inputtooutput[self.lastinputlineno] = inputlineno-inputmarkercnt
					self.outputtoinput[inputlineno-inputmarkercnt] = self.lastinputlineno
					#print "+++KOKOKO [STEP:%s] [%s] %s <- %s" % (num,line,self.lastinputlineno,inputlineno-inputmarkercnt)

				self.lastoutputlineno += 1
				cleanoutput += line + '\n'

		self.output = cleanoutput


	# Extract the coords from an error condition
	#
	def parseErrorCoords(self,error):
		tmp = str(error).split(':')

		try: row = int(tmp[1])
		except ValueError: row = -1

		try: col = int(tmp[2])
		except ValueError: col = -1

		return ":%s:%s" % (row,col)


	def getLineNo(self,error):
		return int(self.parseErrorCoords(error).split(':')[1])


	def getColumnNo(self,error):
		return int(self.parseErrorCoords(error).split(':')[2])


	def visit_FuncDef(self,n):
		if n.decl.name: self.currentFunct = self.scope = n.decl.name
		funcBlock = super(Translator, self).visit_FuncDef(n)
		if n.decl.name: self.currentFunct = self.scope = ''

		return funcBlock


	def visit(self,node,nolinemarkers=False):
		#print ("visit: [%s]" % self.stack)
		method = 'visit_' + node.__class__.__name__
		self.stack.append(node.__class__.__name__)
		self.stacknodes.append(node)
		lineCoords = ''

		# Extracts node coords where possible.
		#
		# This is to update the current coord (= filename+line number)
		# of the input being parsed, considering that:
		#
		# - on the same line of input, there may be more AST nodes (shouldn't enter duplicates)
		# - compound statement and empty statements have line number 0 (shouldn't update the current line)
		# - the same line of input may correspond to many lines of output
		#
		if hasattr(node, 'coord'):
			if ((self.stack[-1] == 'Struct' and self.stack[-2] == 'Typedef') or # typedef structs break linemap
				False):
				#(len(self.stack)>=2 and self.stack[-1] != 'Compound' and self.stack[-2] == 'DoWhile')):
				pass
			elif node.coord:
				linenumber = node.coord.line
				self.currentinputlineno = linenumber

				# Each line of the output is annotated when
				# either it is coming from a new input line number
				# or the input line has generated many output lines,
				# in which case the annotation needs to be repeated at each line..
				#
				if self.currentinputlineno != 0 and self.currentinputlineno not in self.lines:
					self.lines.append(self.currentinputlineno) # now until next input line is read, do not add further markers
					#lineCoords = self._getmarker(node)+'\n' #+ '<-' + str(self.stack[-1]) + '\n'
					lineCoords = '\n'+self._getmarker(node)+'\n' + self._make_indent() #+ '<-' + str(self.stack[-1]) + '\n'

				''' DISABLED!
				This insert linemarkers when visiting complex while() conditions etc.
				if self.currentinputlineno != 0 and self.currentinputlineno != self.lastInputLineNumber:
					lineCoords = '\n'+self._getmarker(node)+'\n' #+ '<-' + str(self.stack[-1]) + '\n'
					self.lastInputLineNumber = self.currentinputlineno
					#####lineCoords = self._getmarker(node)+'\n' #+ '<-' + str(self.stack[-1]) + '\n'
				'''

		a = super(Translator,self).visit(node)
		
		# Note:
		# if the execution gets here and a == none (therefore raising an exception)
		# it is possible that the last visit_something method has not correctly returned any string,
		# which happens for example when a visit_something method does not return a string.
		#
		# TODO: should detect that condition and give an error, if so.
		#
		if not nolinemarkers and self.linemarking == True:
			retval = lineCoords +a
		else:
			retval = a

		self.stack.pop()
		self.stacknodes.pop()

		return retval
















