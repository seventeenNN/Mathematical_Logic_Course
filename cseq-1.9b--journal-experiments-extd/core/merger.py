""" CSeq Program Analysis Framework
	source merging module

Author:
    Omar Inverso

Changes:
    2020.03.24 (CSeq-2.0)
    2019.11.15 (CSeq-1.9) [SV-COMP 2020] pycparserext, general cleanup
    2019.11.15  removed all workarounds for sanitising code
    2018.10.27  no longer stripping the input file from un-necessary headers
    2015.10.20  patch for ldv-races category of SVCOMP16 (from 2_1 to 3_2)
    2015.07.12  new linemapping now mapping back from (outputline) -> (inputline,inputfile)
    2014.12.24 (CSeq-1.0beta)
    2014.10.09 (newseq-0.6a, newseq-0.6c) [SV-COMP 2015]
    2014.10.09  moved all parser-based code transformations from this module to  workarounds.py
    2014.10.09  modifying sanitise() to avoid using the preprocessor at that stage (easier line mapping)
    2014.09.27  new method sanitise() now includes all code-satinising, including thread_local workaround
    2014.09.22  moved thread local workaround from  new.py  to this module
    2014.09.22  load() / loadfromstring() now use gcc rather than cpp to preprocess,
                needed to avoid problems with OSX (where cpp does not remove C++-style comments, causing parsing errors)
    2014.02.25  switched to module.Module base class for modules

Notes: the line mapping mechanism is very different from the other modules
      (linemarkers are generated by the external preprocessor and thus follow
       a different logic)

"""

import module, utils
import getopt, inspect, os, re, sys, subprocess, shlex, time


class Merger(module.Translator):
	inputtooutput = {}		# input lines to output lines
	outputtoinput = {}		# output lines to input lines
	outputtofiles = {}		# output lines to input file names


	def loadfromstring(self, string, env):
		self.cseqenv = env
		self.input = string

		# Pass on to the rest of the chain of modules
		# the list of system headers extracted before merging.
		# Used e.g. when instrumenting.
		#
		self.setoutputparam('systemheaders', self.getsystemheaders(string))

		#string = self._sanitiseinput(string)
		#string = self._gnu_extension_fix(string)
		# Run the preprocessor with linemarker generation.
		#
		# the linemarker has the following format
		# (see https://gcc.gnu.org/onlinedocs/gcc-4.3.6/cpp/Preprocessor-Output.html):
		#
		#   # LINE_NO FILENAME FLAG
		#
		# examples:
		#  # 1 "<stdin>"
		#  # 1 "include/pthread.h" 2
		#
		includestring = ' -I%s' % os.path.dirname(__file__)+'/include' # include fake headers first
		localincludepath = env.inputfile[:env.inputfile.rfind('/')] if '/' in env.inputfile else ''

		if localincludepath!='': includestring += ' -I%s' % localincludepath
		if env.includepath: includestring += ' -I'+' -I'.join(env.includepath.split(':'))

		# Pre-process away GNU C extensions.
		#macros = "-D'__attribute__(x)=' -D'__extension__(x)=' -D'__volatile__=' -D'__asm__(x)='"
		macros = "-D'__attribute__(x)=' -D'__extension__(x)=' -D'__volatile__='"

		# Note: cpp does not strip C++-style comments ('//') from the input code, gcc instead does.
		#cmdline = 'cpp -Iinclude -E -C ' + filename + ' > ' + filename + '.1' + '.c'
		#cmdline = 'gcc -Iinclude -P -E - '  # hyphen at the end forces input from stdin
		cmdline = 'gcc %s -nostdinc %s -E - ' % (macros,includestring) # hyphen at the end forces input from stdin
		p = subprocess.Popen(shlex.split(cmdline), stdout=subprocess.PIPE, stdin=subprocess.PIPE, stderr=subprocess.PIPE)
		string = p.communicate(input=string)[0]

		# After preprocessing, line markers indicate where the lines come from, but
		# this information needs to be removed from the input block, or
		# pycparser won't handle it.
		#
		input = string.splitlines()

		output = ''             # clean input (without linemarkers)
		outputlineno = 0        # current output line number (clean, no linemarkers)
		inputlinenooffset = 0   # number of input lines since the last marker

		# coords fetched from the last linemarker
		lastinputfile = ''      # input file from the last linemarker
		lastinputlineno = 0     # line number from the last linemarker

		for line in input:
			if line.startswith('# '):
				inputlinenooffset = -1
				(lastinputlineno,lastinputfile,lastflag) = utils.linemarkerinfo(line)
			else:
				#  > > >   Our line map   < < <
				outputlineno += 1
				inputlinenooffset += 1
				self.outputtoinput[outputlineno] = lastinputlineno+inputlinenooffset
				self.outputtofiles[outputlineno] = lastinputfile if lastinputfile!='<stdin>' else env.inputfile
				#print "KOKOKO [%s] %s,%s <- %s" % (line,self.outputtoinput[outputlineno],self.outputtofiles[outputlineno],outputlineno)
				output += line + '\n'

		self.markedoutput = string
		self.output = output
		self.lastoutputlineno = outputlineno


	''' Check whether a given header file belongs to the set of the fake ones
	'''
	def issystemheader(self, filename):
		# SMACK headers are not system headers
		# TODO: need proper implementation.
		if filename.startswith('smack'): return False

		fake_include = os.path.dirname(__file__)+'/include/'

		if os.path.isfile(fake_include+filename): return True
		else: return False


	''' Extract from the input source file the list of system headers
	'''
	def getsystemheaders(self, input):
		headers = ''

		for l in input.splitlines():
			m = re.match(r'[ \t]*#[ \t]*include[ \t]*[\"<](.+)[\">]', l)

			if m:
				header = m.group(1)

				if (self.issystemheader(header) and header != 'pthread.h'):
					headers += "#include <%s>\n" % header

		return headers

	''' Override generic line mapping
	'''
	def getlinenumbertable(self):
		str = ''

		for i in range(1,self.lastoutputlineno):
			if i in self.outputtoinput:
				str += "%s,%s <- %s\n" % (self.outputtoinput[i],self.outputtofiles[i], i)

		return str


	def show(self):
		print(self.output)





